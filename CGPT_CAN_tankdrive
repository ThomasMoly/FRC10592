package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.SpeedControllerGroup;

// Updated REVLib 2025 import paths and classes:
import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.SparkMaxConfig;
import com.revrobotics.spark.ResetMode;
import com.revrobotics.spark.PersistMode;
import com.revrobotics.spark.IdleMode;

public class Robot extends TimedRobot {

    // Constants for speeds and durations
    private static final double AUTO_SPEED = 0.6;
    private static final double TELEOP_SPEED_SCALING = 0.6;
    private static final double TURN_SCALING = 0.3;
    private static final double AUTO_DURATION = 3.0;

    // Create a configuration object for our SparkMax motors.
    // Here we set the idle mode to brake. Additional configuration (e.g., inversion,
    // encoder conversion factors, PID parameters) can be added as needed.
    private final SparkMaxConfig sparkConfig = new SparkMaxConfig()
            .idleMode(IdleMode.kBrake);

    // Instantiate the four SparkMax motor controllers using REVLib 2025.
    // Use brushed motors (MotorType.kBrushed) and apply the desired CAN IDs.
    // Mapping:
    // - Right Motors: IDs 1 (posterior) and 2 (anterior)
    // - Left Motors: IDs 3 (posterior) and 4 (anterior)
    private SparkMax rightMotor1 = new SparkMax(1, MotorType.kBrushed);
    private SparkMax rightMotor2 = new SparkMax(2, MotorType.kBrushed);
    private SparkMax leftMotor1  = new SparkMax(3, MotorType.kBrushed);
    private SparkMax leftMotor2  = new SparkMax(4, MotorType.kBrushed);

    // Group the left side and right side motors.
    private SpeedControllerGroup leftMotors = new SpeedControllerGroup(leftMotor1, leftMotor2);
    private SpeedControllerGroup rightMotors = new SpeedControllerGroup(rightMotor1, rightMotor2);

    // Create the DifferentialDrive object for arcade drive control.
    private DifferentialDrive drive = new DifferentialDrive(leftMotors, rightMotors);

    // Joystick for teleop control (connected to Driver Station port 0)
    private Joystick joy1 = new Joystick(0);
    
    // Variable to track the start time in autonomous mode.
    private double startTime;

    @Override
    public void robotInit() {
        // Configure each SparkMax using the new REVLib 2025 configuration system.
        rightMotor1.configure(sparkConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);
        rightMotor2.configure(sparkConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);
        leftMotor1.configure(sparkConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);
        leftMotor2.configure(sparkConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);

        // Invert the right side of the drivetrain so a positive speed moves the robot forward.
        drive.setRightSideInverted(true);
    }

    @Override
    public void autonomousInit() {
        // Record the time at which autonomous mode begins.
        startTime = Timer.getFPGATimestamp();
    }

    @Override
    public void autonomousPeriodic() {
        double time = Timer.getFPGATimestamp();
        System.out.println("Autonomous Time: " + (time - startTime));

        // Drive forward for AUTO_DURATION seconds.
        if (time - startTime < AUTO_DURATION) {
            drive.arcadeDrive(AUTO_SPEED, 0.0);
        } else {
            drive.arcadeDrive(0.0, 0.0);
        }
    }

    @Override
    public void teleopInit() {
        // Any teleop initialization code goes here.
    }

    @Override
    public void teleopPeriodic() {
        // Read joystick axes (apply a deadband for small inputs).
        double speed = applyDeadband(-joy1.getRawAxis(1), 0.05) * TELEOP_SPEED_SCALING;
        double turn = applyDeadband(joy1.getRawAxis(4), 0.05) * TURN_SCALING;

        // Arcade drive control.
        drive.arcadeDrive(speed, turn);
        System.out.println("Joystick Speed: " + speed + " Turn: " + turn);
    }

    @Override
    public void testInit() {
    }

    @Override
    public void testPeriodic() {
    }

    /**
     * Applies a deadband to joystick input to ignore small values.
     * @param value The input value from the joystick.
     * @param threshold The minimum magnitude to register.
     * @return The adjusted value (or 0 if within the deadband).
     */
    private double applyDeadband(double value, double threshold) {
        return (Math.abs(value) > threshold) ? value : 0.0;
    }
}
